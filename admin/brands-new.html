<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ShelfAssured ‚Ä¢ Brand Onboarding (Admin)</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif;margin:24px;background:#f6f7f9}
    .wrap{max-width:1000px;margin:0 auto}
    .card{background:#fff;border:1px solid #e5e7eb;border-radius:16px;box-shadow:0 1px 2px rgba(0,0,0,.04);padding:16px;margin-bottom:16px}
    h1{font-size:22px;margin:0 0 8px}
    h2{font-size:16px;margin:0 0 4px}
    .hint{color:#6b7280;font-size:12px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .full{grid-column:1 / -1}
    label{font-size:12px;font-weight:600;margin-bottom:6px;display:block}
    input,select,textarea{width:100%;padding:10px 12px;border:1px solid #d1d5db;border-radius:12px}
    textarea{min-height:84px}
    .row{display:flex;gap:8px;align-items:center}
    .btn{background:#111827;color:#fff;border:0;border-radius:12px;padding:10px 14px;cursor:pointer}
    .btn.alt{background:#374151}
    .btn.ghost{background:#fff;color:#111827;border:1px solid #e5e7eb}
    .pill{border:1px dashed #e5e7eb;border-radius:12px;padding:12px}
    .list{display:flex;flex-direction:column;gap:12px}
    .kpi{display:flex;gap:8px;flex-wrap:wrap}
    .err{color:#b91c1c;font-size:13px}
    .ok{color:#065f46;font-size:13px}
    code.small{font-size:11px;color:#6b7280}
    .back-link{display:inline-flex;align-items:center;color:#2563eb;text-decoration:none;font-size:14px;font-weight:500;transition:color 0.2s}
    .back-link:hover{color:#1d4ed8}
  </style>
</head>
<body>
  <div class="wrap">
    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
      <a href="dashboard.html" class="back-link">
        ‚Üê Back to Admin Dashboard
      </a>
    </div>
    <h1>Brand Onboarding</h1>
    <p class="hint">We stop the silent, invisible margin erosion caused by bad retail execution. Help us understand your retail landscape so we can deliver real-time shelf visibility and competitive intelligence.</p>

    <div id="msg" class="hint"></div>

    <form id="form" class="card">
      <h2>Your Brand</h2>
      <div class="grid">
        <div>
          <label>Select Existing Brand (optional)</label>
          <div class="relative">
            <input type="text" id="brand_search" placeholder="Search for existing brand..." autocomplete="off" />
            <div id="brand-suggestions" class="absolute z-10 w-full bg-white border border-gray-300 rounded-lg shadow-lg hidden mt-1 max-h-48 overflow-y-auto"></div>
          </div>
          <p class="hint" style="font-size:11px;margin-top:4px;">Or create a new brand by entering name below</p>
        </div>
        <div>
          <label>Brand Name *</label>
          <input id="brand_name" placeholder="Full Business Name" required />
          <input type="hidden" id="brand_id" />
        </div>
        <div>
          <label>Website</label>
          <input id="brand_site" placeholder="https://www.company.com" />
        </div>
        <div>
          <label>Primary Email</label>
          <input id="brand_email" type="email" placeholder="contact@company.com" />
        </div>
        <div>
          <label>Phone</label>
          <input id="brand_phone" placeholder="(555) 123-4567" />
        </div>
        <div class="full">
          <label>Brand Logo</label>
          <div class="flex items-center space-x-4">
            <input type="file" id="brand_logo_file" accept="image/*" class="hidden" />
            <button type="button" onclick="document.getElementById('brand_logo_file').click()" 
                    class="px-4 py-2 bg-gray-200 rounded-lg hover:bg-gray-300 text-sm">
              Upload Logo
            </button>
            <input type="text" id="brand_logo_url" placeholder="Or paste logo URL" class="flex-1" />
            <div id="brand_logo_preview" class="w-16 h-16 border border-gray-300 rounded-lg flex items-center justify-center bg-gray-50 hidden">
              <img id="brand_logo_preview_img" src="" alt="Logo preview" class="max-w-full max-h-full object-contain" />
            </div>
          </div>
          <p class="hint" style="font-size:11px;margin-top:4px;">Upload image or paste URL (JPG, PNG, SVG)</p>
        </div>
        <div class="full">
          <label>Address</label>
          <input id="brand_addr" placeholder="Street, City, State, ZIP" />
        </div>
      </div>
    </form>

    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div>
          <h2>Products We'll Monitor</h2>
          <p class="hint">Tell us which products need our eyes on the shelf. We'll track OOS, compliance, pricing, and competitive moves for each one.</p>
        </div>
        <div class="row">
          <input type="file" id="productsCsv" accept=".csv" style="display:none" />
          <button class="btn ghost" id="uploadProducts">üìÅ Upload CSV</button>
          <button class="btn ghost" id="downloadProductsTemplate">üì• Template</button>
          <button class="btn ghost" id="addProduct">+ Add Product</button>
        </div>
      </div>
      <div id="products" class="list"></div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div>
          <h2>Retail Locations</h2>
          <p class="hint">Point us to your battleground stores. We'll deploy our field team to monitor execution, compliance, and competitive activity.</p>
        </div>
        <div class="row">
          <input type="file" id="storesCsv" accept=".csv" style="display:none" />
          <button class="btn ghost" id="uploadStores">üìÅ Upload CSV</button>
          <button class="btn ghost" id="downloadStoresTemplate">üì• Template</button>
          <button class="btn ghost" id="addStore">+ Add Store</button>
        </div>
      </div>
      <div id="stores" class="list"></div>
    </div>

    <div class="card">
      <div class="kpi">
        <button class="btn" id="saveAll">Deploy ShelfAssured</button>
        <button class="btn alt" id="saveDraft">üíæ Save Draft</button>
        <button class="btn ghost" id="loadDraft">üìÇ Load Draft</button>
        <span id="stat" class="hint"></span>
        <a id="viewBrand" class="hint" style="text-decoration:underline;display:none">View brand ‚Üí</a>
      </div>
      <div id="error" class="err"></div>
      <div id="ok" class="ok"></div>
      <div class="pill" style="margin-top:10px">
        <code class="small">Mission Brief: We'll establish real-time shelf visibility across your retail network, tracking OOS, compliance, pricing integrity, and competitive moves.</code>
      </div>
    </div>
  </div>

  <template id="tplProduct">
    <div class="pill">
      <div class="grid">
        <div>
          <label>Product Name *</label>
          <input data-k="name" placeholder="Specific Product Name" />
        </div>
        <div>
          <label>UPC/SKU *</label>
          <input data-k="barcode" placeholder="123456789012" />
        </div>
        <div>
          <label>Size</label>
          <input data-k="size" placeholder="16 oz" />
        </div>
        <div>
          <label>Suggested Retail Price</label>
          <input data-k="suggested_retail_price" placeholder="9.99" type="number" step="0.01" />
        </div>
        <div>
          <label>Image URL</label>
          <input data-k="image_url" placeholder="https://‚Ä¶" />
        </div>
        <div>
          <label>Category</label>
          <input data-k="category" placeholder="Sausage" />
        </div>
      </div>
      <div class="row" style="margin-top:8px;justify-content:flex-end">
        <button class="btn alt" data-action="remove">Remove</button>
      </div>
    </div>
  </template>

  <template id="tplStore">
    <div class="pill">
      <div class="grid">
        <div>
          <label>Retailer</label>
          <input data-k="retailer" placeholder="Target, Walmart, Kroger" />
        </div>
        <div>
          <label>Store Name</label>
          <input data-k="name" placeholder="Store Location Name" />
        </div>
        <div>
          <label>Address</label>
          <input data-k="address" placeholder="Street Address" />
        </div>
        <div>
          <label>City</label>
          <input data-k="city" placeholder="Houston" />
        </div>
        <div>
          <label>State & ZIP</label>
          <input data-k="state_zip" placeholder="TX 77057-3061" />
        </div>
        <div>
          <label>Metro Area</label>
          <input data-k="metro" placeholder="Austin-Round Rock, TX MSA" />
        </div>
      </div>
      <div class="row" style="margin-top:8px;justify-content:flex-end">
        <button class="btn alt" data-action="remove">Remove</button>
      </div>
    </div>
  </template>

  <script src="./config.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    (function(){
      const { SUPABASE_URL, SUPABASE_ANON_KEY } = window.SA_CONFIG || {};
      const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

      const el = (id) => document.getElementById(id);
      const products = el('products');
      const stores = el('stores');
      const stat = el('stat');
      const ok = el('ok');
      const err = el('error');
      const viewBrand = el('viewBrand');

      // add initial blank rows
      function addProductRow(){
        const tpl = el('tplProduct').content.cloneNode(true);
        tpl.querySelector('[data-action="remove"]').onclick = (e)=>{
          e.preventDefault(); e.target.closest('.pill').remove();
        };
        products.appendChild(tpl);
      }
      function addStoreRow(){
        const tpl = el('tplStore').content.cloneNode(true);
        tpl.querySelector('[data-action="remove"]').onclick = (e)=>{
          e.preventDefault(); e.target.closest('.pill').remove();
        };
        stores.appendChild(tpl);
      }
      addProductRow();
      addStoreRow();

      el('addProduct').onclick = (e)=>{ e.preventDefault(); addProductRow(); };
      el('addStore').onclick = (e)=>{ e.preventDefault(); addStoreRow(); };

      // CSV Upload functionality
      el('uploadProducts').onclick = (e)=>{ e.preventDefault(); el('productsCsv').click(); };
      el('uploadStores').onclick = (e)=>{ e.preventDefault(); el('storesCsv').click(); };

      el('productsCsv').onchange = (e)=>{ handleCsvUpload(e, 'products'); };
      el('storesCsv').onchange = (e)=>{ handleCsvUpload(e, 'stores'); };

      el('downloadProductsTemplate').onclick = (e)=>{ e.preventDefault(); downloadTemplate('products'); };
      el('downloadStoresTemplate').onclick = (e)=>{ e.preventDefault(); downloadTemplate('stores'); };

      // Draft functionality
      el('saveDraft').onclick = (e)=>{ e.preventDefault(); saveDraft(); };
      el('loadDraft').onclick = (e)=>{ e.preventDefault(); loadDraft(); };

      function saveDraft() {
        const draft = {
          brand: {
            name: el('brand_name').value,
            site: el('brand_site').value,
            email: el('brand_email').value,
            phone: el('brand_phone').value,
            addr: el('brand_addr').value
          },
          products: readProducts(),
          stores: readStores()
        };
        localStorage.setItem('brandDraft', JSON.stringify(draft));
        stat.textContent = 'Draft saved to browser storage';
        setTimeout(() => stat.textContent = '', 3000);
      }

      function loadDraft() {
        const draft = localStorage.getItem('brandDraft');
        if (!draft) {
          stat.textContent = 'No draft found';
          setTimeout(() => stat.textContent = '', 3000);
          return;
        }
        
        const data = JSON.parse(draft);
        
        // Load brand data
        el('brand_name').value = data.brand.name || '';
        el('brand_site').value = data.brand.site || '';
        el('brand_email').value = data.brand.email || '';
        el('brand_phone').value = data.brand.phone || '';
        el('brand_addr').value = data.brand.addr || '';
        
        // Clear existing products/stores
        products.innerHTML = '';
        stores.innerHTML = '';
        
        // Load products
        data.products.forEach(product => {
          addProductRow();
          const lastRow = products.lastElementChild;
          Object.keys(product).forEach(key => {
            const input = lastRow.querySelector(`[data-k="${key}"]`);
            if (input) input.value = product[key] || '';
          });
        });
        
        // Load stores
        data.stores.forEach(store => {
          addStoreRow();
          const lastRow = stores.lastElementChild;
          Object.keys(store).forEach(key => {
            const input = lastRow.querySelector(`[data-k="${key}"]`);
            if (input) input.value = store[key] || '';
          });
        });
        
        stat.textContent = `Loaded draft: ${data.products.length} products, ${data.stores.length} stores`;
        setTimeout(() => stat.textContent = '', 3000);
      }

      function downloadTemplate(type) {
        const templates = {
          products: 'name,barcode,size,category\nProduct Name 1,123456789012,16 oz,Beverages\nProduct Name 2,123456789013,32 oz,Beverages',
          stores: 'retailer,name,address,city,state_zip\nH-E-B,San Felipe H-E-B,5895 San Felipe Street,Houston,TX 77057-3061\nKroger,Kroger - Bunker Hill,17455 Spring Cypress Road,Houston,TX 77090'
        };
        
        const blob = new Blob([templates[type]], { type: 'text/csv' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${type}-template.csv`;
        a.click();
        window.URL.revokeObjectURL(url);
      }

      function handleCsvUpload(event, type) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
          const csv = e.target.result;
          const lines = csv.split('\n').filter(line => line.trim());
          const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
          
          if (type === 'products') {
            // Expected headers: name,barcode,size,category
            for (let i = 1; i < lines.length; i++) {
              const values = lines[i].split(',').map(v => v.trim());
              const product = {};
              headers.forEach((header, index) => {
                product[header] = values[index] || '';
              });
              
              if (product.name && product.barcode) {
                addProductRow();
                const lastRow = products.lastElementChild;
                Object.keys(product).forEach(key => {
                  const input = lastRow.querySelector(`[data-k="${key}"]`);
                  if (input) input.value = product[key];
                });
              }
            }
          } else if (type === 'stores') {
            // Expected headers: retailer,name,address,city,state_zip,metro
            for (let i = 1; i < lines.length; i++) {
              const values = lines[i].split(',').map(v => v.trim());
              const store = {};
              headers.forEach((header, index) => {
                store[header] = values[index] || '';
              });
              
              if (store.name || store.address) {
                addStoreRow();
                const lastRow = stores.lastElementChild;
                Object.keys(store).forEach(key => {
                  const input = lastRow.querySelector(`[data-k="${key}"]`);
                  if (input) input.value = store[key];
                });
              }
            }
          }
          
          stat.textContent = `Loaded ${lines.length - 1} ${type} from CSV`;
          setTimeout(() => stat.textContent = '', 3000);
        };
        reader.readAsText(file);
      }

      function readProducts(){
        return Array.from(products.querySelectorAll('.pill')).map(card=>{
          const get = k => (card.querySelector(`[data-k="${k}"]`).value||'').trim();
          return {
            name: get('name'),
            barcode: get('barcode'),
            size: get('size')||null,
            category: get('category')||null,
          };
        }).filter(p=>p.name && p.barcode);
      }
      function readStores(){
        return Array.from(stores.querySelectorAll('.pill')).map(card=>{
          const get = k => (card.querySelector(`[data-k="${k}"]`).value||'').trim();
          return {
            retailer: get('retailer')||null,
            name: get('name')||null,
            address: get('address')||null,
            city: get('city')||null,
            state_zip: get('state_zip')||null,
            metro: get('metro')||null,
          };
        }).filter(s=> s.name || s.address);
      }

      // New normalization functions with retailer alias lookup
      const toZip5 = (s='') => (s.match(/\d/g) || []).join('').slice(0,5);
      const normText = s => (s||'').toLowerCase().normalize('NFKC').replace(/\s+/g,' ').trim();
      const normStreet = s => normText(s).replace(/[.,]/g,'').replace(/\b(ste|suite|unit)\b.*$/,'');
      const normName = s => normText(s).replace(/[\u2010-\u2015]/g,'-');

      async function resolveBannerId(retailerRaw){
        const alias = normName(retailerRaw);
        // Try retailer_banner_aliases first
        const { data: bbaRow } = await supabase
          .from('retailer_banner_aliases')
          .select('banner_id')
          .eq('alias', alias)
          .maybeSingle();
        if (bbaRow?.banner_id) return bbaRow?.banner_id;
        
        // Fallback to retailers table
        const { data: rRow } = await supabase
          .from('retailer_aliases')
          .select('retailer_id')
          .eq('alias', alias)
          .maybeSingle();
        if (rRow?.retailer_id) {
          // Get banner_id from retailer_id
          const { data: banner } = await supabase
            .from('retailer_banners')
            .select('id')
            .eq('retailer_id', rRow.retailer_id)
            .limit(1)
            .maybeSingle();
          return banner?.id || null;
        }
        return null;
      }

      // Legacy normalization functions (kept for backward compatibility)
      function normalizeRetailer(name) {
        if (!name) return '';
        return normName(name);
      }

      function normalizeStreet(address) {
        if (!address) return '';
        return address.toLowerCase()
          .replace(/[\u2011\u2013\u2014]/g, '-') // Unicode hyphens
          .replace(/\b(rd|road)\b/g, 'road')
          .replace(/\b(st|street)\b/g, 'street')
          .replace(/\b(ave|avenue)\b/g, 'avenue')
          .replace(/\b(blvd|boulevard)\b/g, 'boulevard')
          .replace(/\b(ste|suite)\s*#?\d*/g, '') // Remove suite/ste numbers
          .replace(/[^a-z0-9\s]/g, '') // Keep only alphanumeric and spaces
          .replace(/\s+/g, ' ') // Collapse whitespace
          .trim();
      }

      function normalizeCity(city) {
        if (!city) return '';
        return city.toLowerCase().trim();
      }

      function normalizeState(stateZip) {
        if (!stateZip) return '';
        const state = stateZip.split(' ')[0];
        return state ? state.toUpperCase() : '';
      }

      function normalizeZip(stateZip) {
        if (!stateZip) return '';
        const zipMatch = stateZip.match(/\d{5}/);
        return zipMatch ? zipMatch[0] : '';
      }

      function normalizeName(name) {
        if (!name) return '';
        return name.toLowerCase()
          .replace(/[\u2011\u2013\u2014]/g, '-') // Unicode hyphens
          .replace(/\s+/g, ' ') // Collapse spaces
          .trim();
      }

      async function findExistingStore(storeData) {
        const retailerNorm = normalizeRetailer(storeData.retailer);
        const streetNorm = normalizeStreet(storeData.address);
        const cityNorm = normalizeCity(storeData.city);
        const state = normalizeState(storeData.state_zip);
        const zip5 = normalizeZip(storeData.state_zip);
        const nameNorm = normalizeName(storeData.name);

        console.log(`Matching: ${retailerNorm} | ${streetNorm} | ${cityNorm} | ${state} | ${zip5}`);

        // Strategy 1: Address + ZIP (best signal)
        if (streetNorm && cityNorm && state && zip5) {
          const { data, error } = await supabase
            .from('stores')
            .select('id, name, store_chain, address, city, state, zip_code')
            .eq('zip_code', zip5)
            .eq('state', state)
            .ilike('address', `%${streetNorm.split(' ')[0]}%`) // First word of street
            .ilike('city', `%${cityNorm}%`)
            .limit(1);
          
          if (!error && data && data.length > 0) {
            console.log(`‚úÖ Address+ZIP match: ${data[0].name}`);
            return data[0].id;
          }
        }

        // Strategy 2: Retailer + Address (no zip required)
        if (retailerNorm && streetNorm && cityNorm && state) {
          const { data, error } = await supabase
            .from('stores')
            .select('id, name, store_chain, address, city, state, zip_code')
            .eq('state', state)
            .ilike('store_chain', `%${storeData.retailer}%`) // Use original for fuzzy match
            .ilike('address', `%${streetNorm.split(' ')[0]}%`)
            .ilike('city', `%${cityNorm}%`)
            .limit(1);
          
          if (!error && data && data.length > 0) {
            console.log(`‚úÖ Retailer+Address match: ${data[0].name}`);
            return data[0].id;
          }
        }

        // Strategy 3: Name + ZIP (weaker)
        if (nameNorm && zip5) {
          const { data, error } = await supabase
            .from('stores')
            .select('id, name, store_chain, address, city, state, zip_code')
            .eq('zip_code', zip5)
            .ilike('name', `%${nameNorm.split(' ')[0]}%`) // First word of name
            .limit(1);
          
          if (!error && data && data.length > 0) {
            console.log(`‚úÖ Name+ZIP match: ${data[0].name}`);
            return data[0].id;
          }
        }

        // Strategy 4: Retailer + ZIP (guarded fallback)
        if (retailerNorm && zip5) {
          // First check if there's only one store for this retailer+zip
          const { data: countData, error: countError } = await supabase
            .from('stores')
            .select('id', { count: 'exact' })
            .eq('zip_code', zip5)
            .ilike('store_chain', `%${storeData.retailer}%`);
          
          if (!countError && countData && countData.length === 1) {
            console.log(`‚úÖ Retailer+ZIP match (single store): ${countData[0].name}`);
            return countData[0].id;
          } else {
            console.log(`‚ö†Ô∏è Multiple stores for ${storeData.retailer} in ${zip5}, skipping fallback`);
          }
        }

        console.log(`‚ùå No match found for: ${storeData.name}`);
        return null;
      }

      async function saveAll(){
        err.textContent = ''; ok.textContent = ''; stat.textContent=''; viewBrand.style.display='none';

        const name = document.getElementById('brand_name').value.trim();
        if(!name){ err.textContent='Brand name is required.'; return; }
        const site = document.getElementById('brand_site').value.trim() || null;
        const email = document.getElementById('brand_email').value.trim() || null;
        const phone = document.getElementById('brand_phone').value.trim() || null;
        const addr = document.getElementById('brand_addr').value.trim() || null;
        
        // Get logo URL or file (will upload after we have brandId)
        let logoUrl = document.getElementById('brand_logo_url').value.trim() || null;
        const logoFile = document.getElementById('brand_logo_file').files[0];

        const prodList = readProducts();
        const storeList = readStores();
        if(prodList.length === 0){ err.textContent='Add at least one product with name and identifier.'; return; }

        stat.textContent='Saving brand‚Ä¶';
        
        // Check if existing brand was selected
        const existingBrandId = document.getElementById('brand_id').value;
        let brandId;
        
        if (existingBrandId) {
          // Update existing brand
          brandId = existingBrandId;
          
          // Upload logo file if provided (now we have brandId)
          if (logoFile) {
            stat.textContent='Uploading logo‚Ä¶';
            try {
              const fileName = `${brandId}_${Date.now()}.${logoFile.name.split('.').pop()}`;
              const { data: uploadData, error: uploadError } = await supabase.storage
                .from('brand_logos')
                .upload(fileName, logoFile, { upsert: false });
              
              if (uploadError) {
                console.error('Logo upload error:', uploadError);
                if (uploadError.message.includes('Bucket not found')) {
                  // Non-blocking: warn but continue without logo
                  console.warn('Brand logos storage bucket not configured. Skipping logo upload. Use logo URL field instead.');
                  stat.textContent = 'Warning: Logo bucket not configured. Using URL if provided, or continue without logo.';
                  // Don't return - continue with brand save without logo
                  logoUrl = null; // Clear logoUrl so we don't try to save a bad URL
                } else if (uploadError.message.includes('row-level security policy') || uploadError.message.includes('RLS')) {
                  // RLS policy issue
                  console.warn('Storage bucket RLS policy blocking upload. Adding policies in Supabase Dashboard ‚Üí Storage ‚Üí brand_logos ‚Üí Policies');
                  stat.textContent = 'Upload blocked by security policy. See FIX-STORAGE-RLS-BRAND-LOGOS.md for instructions. You can continue with URL only.';
                  logoUrl = null; // Don't save a bad URL
                  // Don't throw - allow user to continue without logo
                } else {
                  throw uploadError;
                }
              }
              
              const { data: urlData } = supabase.storage
                .from('brand_logos')
                .getPublicUrl(fileName);
              
              // Ensure we have the public URL
              if (urlData && urlData.publicUrl) {
                logoUrl = urlData.publicUrl;
                console.log('‚úÖ Logo uploaded successfully:', logoUrl);
              } else {
                console.error('‚ùå Failed to get public URL:', urlData);
                throw new Error('Failed to get public URL for uploaded logo');
              }
            } catch (uploadErr) {
              err.textContent = `Logo upload failed: ${uploadErr.message}. You can continue with URL only.`;
              return;
            }
          }
          
          // Update existing brand (including logo)
          const { error: updateErr } = await supabase
            .from('brands')
            .update({
              name: name,
              website: site,
              primary_email: email,
              phone: phone,
              address: addr,
              logo_url: logoUrl
            })
            .eq('id', brandId);
          if(updateErr){ err.textContent=updateErr.message; return; }
        } else {
          // Create new brand or upsert by name
          const { data: brandResult, error: rpcErr } = await supabase.rpc('upsert_brand_public', {
            p_id: null,
            p_name: name,
            p_website: site,
            p_primary_email: email,
            p_phone: phone,
            p_address: addr,
          });
          if(rpcErr){ err.textContent=rpcErr.message; return; }
          brandId = brandResult;
          
          // Upload logo file if provided (now we have brandId)
          if (logoFile) {
            stat.textContent='Uploading logo‚Ä¶';
            try {
              const fileName = `${brandId}_${Date.now()}.${logoFile.name.split('.').pop()}`;
              const { data: uploadData, error: uploadError } = await supabase.storage
                .from('brand_logos')
                .upload(fileName, logoFile, { upsert: false });
              
              if (uploadError) {
                console.error('Logo upload error:', uploadError);
                if (uploadError.message.includes('Bucket not found')) {
                  // Non-blocking: warn but continue without logo
                  console.warn('Brand logos storage bucket not configured. Skipping logo upload. Use logo URL field instead.');
                  stat.textContent = 'Warning: Logo bucket not configured. Using URL if provided, or continue without logo.';
                  // Don't throw - continue with brand save without logo
                  logoUrl = null; // Clear logoUrl so we don't try to save a bad URL
                } else if (uploadError.message.includes('row-level security policy') || uploadError.message.includes('RLS')) {
                  // RLS policy issue
                  console.warn('Storage bucket RLS policy blocking upload. Add policies in Supabase Dashboard ‚Üí Storage ‚Üí brand_logos ‚Üí Policies');
                  stat.textContent = 'Upload blocked by security policy. See FIX-STORAGE-RLS-BRAND-LOGOS.md for instructions. You can continue with URL only.';
                  logoUrl = null; // Don't save a bad URL
                  // Don't throw - allow user to continue without logo
                } else {
                  throw uploadError;
                }
              } else {
                const { data: urlData } = supabase.storage
                  .from('brand_logos')
                  .getPublicUrl(fileName);
                
                // Ensure we have the public URL
                if (urlData && urlData.publicUrl) {
                  logoUrl = urlData.publicUrl;
                  console.log('‚úÖ Logo uploaded successfully:', logoUrl);
                } else {
                  console.error('‚ùå Failed to get public URL:', urlData);
                  // Don't throw - continue without logo
                  logoUrl = null;
                }
              }
            } catch (uploadErr) {
              console.warn('Logo upload failed:', uploadErr.message, '- continuing without logo');
            }
          }
          
          // Update logo_url after brand creation (if we have a logo URL)
          if (logoUrl) {
            await supabase
              .from('brands')
              .update({ logo_url: logoUrl })
              .eq('id', brandId);
          }
        }

        // 2) products - upsert by SKU (globally unique) with duplicate prevention
        stat.textContent='Saving products‚Ä¶';
        const productIds = [];
        const productLabels = {}; // Track brand-specific labels
        const duplicateSkus = []; // Track duplicates to warn user
        
        for(const p of prodList){
          const sku = (p.barcode || p.sku || '').trim();
          const productName = (p.name || '').trim();
          const productUPC = sku; // UPC is same as SKU in our schema
          
          if(!sku || !productName) {
            console.warn('Skipping product with missing SKU or name');
            continue;
          }
          
          // Step 1: Check if product exists by SKU (globally unique)
          const { data: existingProduct } = await supabase
            .from('products')
            .select('id, name, upc, sku')
            .eq('sku', sku)
            .maybeSingle();
          
          let productId;
          
          if (existingProduct) {
            // Product exists - check if already linked to this brand
            const { data: existingLink } = await supabase
              .from('brand_products')
              .select('id, product_label')
              .eq('brand_id', brandId)
              .eq('product_id', existingProduct.id)
              .maybeSingle();
            
            if (existingLink) {
              // Already linked to this brand - skip or update label
              console.log(`Product ${sku} already linked to this brand`);
              duplicateSkus.push({ sku, name: existingProduct.name, reason: 'Already linked to this brand' });
              productId = existingProduct.id; // Use existing product ID for linking
            } else {
              // Product exists but not linked to this brand - link it
              productId = existingProduct.id;
              console.log(`Linking existing product ${sku} to brand ${brandId}`);
            }
            
            // Store brand-specific label if CSV name differs
            if (productName && existingProduct.name && productName !== existingProduct.name) {
              productLabels[productId] = productName;
            }
          } else {
            // Product doesn't exist - create minimal product
            const { data: newProduct, error: insErr } = await supabase
              .from('products')
              .insert({
                sku: sku,
                name: productName,
                upc: productUPC,
                category: p.category || 'General'
              })
              .select('id')
              .single();
            
            if (insErr) {
              if (insErr.code === '23505') {
                // Unique constraint violation - product was created between check and insert
                // Retry fetch
                const { data: retryProduct } = await supabase
                  .from('products')
                  .select('id, name, upc, sku')
                  .eq('sku', sku)
                  .maybeSingle();
                
                if (retryProduct) {
                  productId = retryProduct.id;
                  duplicateSkus.push({ sku, name: retryProduct.name, reason: 'Created by another process' });
                } else {
                  err.textContent = 'Product error: ' + insErr.message;
                  return;
                }
              } else {
                err.textContent = 'Product error: ' + insErr.message;
                return;
              }
            } else {
              productId = newProduct.id;
            }
          }
          
          productIds.push(productId);
        }
        
        // Warn about duplicates if any
        if (duplicateSkus.length > 0) {
          const dupList = duplicateSkus.map(d => `${d.name} (SKU: ${d.sku})`).join(', ');
          console.warn('‚ö†Ô∏è Duplicate products detected:', dupList);
          stat.textContent = `Note: ${duplicateSkus.length} product(s) were already in the system`;
          setTimeout(() => { if (stat.textContent.includes('Note:')) stat.textContent = ''; }, 5000);
        }
        
        // Step 3: Link products to brand via brand_products (skip if already linked)
        stat.textContent='Linking products to brand‚Ä¶';
        
        // Filter out products already linked to this brand to avoid duplicates
        const linksToCreate = [];
        for (const productId of productIds) {
          // Check if already linked
          const { data: existingLink } = await supabase
            .from('brand_products')
            .select('id')
            .eq('brand_id', brandId)
            .eq('product_id', productId)
            .maybeSingle();
          
          if (!existingLink) {
            linksToCreate.push({
              brand_id: brandId,
              product_id: productId,
              product_label: productLabels[productId] || null
            });
          } else {
            // Already linked - update product_label if different
            if (productLabels[productId]) {
              await supabase
                .from('brand_products')
                .update({ product_label: productLabels[productId] })
                .eq('id', existingLink.id);
            }
          }
        }
        
        if (linksToCreate.length > 0) {
          const { error: bpErr } = await supabase
            .from('brand_products')
            .upsert(linksToCreate, {
              onConflict: 'brand_id,product_id',
              ignoreDuplicates: false
            });
          
          if (bpErr) {
            err.textContent = 'Brand products link error: ' + bpErr.message;
            return;
          }
        }

        // 3) stores (smart matching against existing stores, then link via brand_stores)
        stat.textContent='Matching stores against existing database‚Ä¶';
        const storeIds = [];
        const unmatchedStores = [];
        
        for(const s of storeList){
          try {
            const banner_id = await resolveBannerId(s.retailer);
            if (!banner_id) {
              // Don't block - collect as unmatched
              unmatchedStores.push({
                retailer: s.retailer,
                name: s.name,
                address: s.address,
                reason: 'Retailer not found in retailer_banner_aliases'
              });
              continue;
            }
            
            const street_norm = normStreet(s.address);
            const city_norm = normText(s.city);
            const state = (s.state_zip || '').trim().split(/\s+/)[0]?.toUpperCase() || null;
            const zip5 = toZip5(s.state_zip);
            
            // Try to find existing store first
            let storeId = await findExistingStore(s);
            
            if (!storeId) {
              // Store doesn't exist - create only if we have enough info
              if (s.address && s.city && state && zip5) {
                const payload = {
                  banner_id,
                  name: s.name || `${s.retailer} - ${s.city}`,
                  address: s.address,
                  city: s.city,
                  state: state,
                  zip_code: zip5,
                  street_norm,
                  city_norm,
                  metro: s.metro,
                  status: 'unverified'
                };
                
                const { data: newStore, error: sErr } = await supabase
                  .from('stores')
                  .insert(payload)
                  .select('id')
                  .single();
                
                if(sErr){ 
                  // Don't block - collect as unmatched
                  unmatchedStores.push({
                    retailer: s.retailer,
                    name: s.name,
                    address: s.address,
                    reason: sErr.message
                  });
                  continue;
                }
                
                storeId = newStore.id;
                console.log(`Created new store: ${s.name || payload.name}`);
              } else {
                // Not enough info to create - collect as unmatched
                unmatchedStores.push({
                  retailer: s.retailer,
                  name: s.name,
                  address: s.address,
                  reason: 'Insufficient address data to create store'
                });
                continue;
              }
            }
            
            storeIds.push(storeId);
          } catch (error) {
            console.error('Error processing store:', error);
            unmatchedStores.push({
              retailer: s.retailer || 'Unknown',
              name: s.name || 'Unknown',
              address: s.address || 'Unknown',
              reason: error.message
            });
            // Don't block - continue processing other stores
          }
        }
        
        // Step 4: Link matched stores to brand via brand_stores
        stat.textContent='Linking stores to brand‚Ä¶';
        const brandStoreLinks = storeIds.map(storeId => ({
          brand_id: brandId,
          store_id: storeId,
          source: 'csv'
        }));
        
        if (brandStoreLinks.length > 0) {
          const { error: bsErr } = await supabase
            .from('brand_stores')
            .upsert(brandStoreLinks, {
              onConflict: 'brand_id,store_id',
              ignoreDuplicates: false
            });
          
          if (bsErr) {
            console.warn('Brand stores link error:', bsErr);
            // Don't block - this is secondary data
          }
        }
        
        // Step 5: Show success message with unmatched stores count
        const productCount = productIds.length;
        const storeCount = storeIds.length;
        const unmatchedCount = unmatchedStores.length;
        
        let successMsg = `Saved! Brand created ‚Ä¢ ${productCount} products linked ‚Ä¢ ${storeCount} stores linked`;
        if (unmatchedCount > 0) {
          successMsg += ` ‚Ä¢ ${unmatchedCount} unmatched stores to review`;
          console.warn('Unmatched stores:', unmatchedStores);
          // Store unmatched in localStorage for admin review (optional)
          localStorage.setItem(`unmatched_stores_${brandId}`, JSON.stringify(unmatchedStores));
        }
        
        ok.textContent = successMsg;
        stat.textContent='';
        viewBrand.href = './brand-detail.html?id=' + brandId;
        viewBrand.style.display = 'inline';
      }

      // Brand search/autocomplete for selecting existing brands
      let allBrands = [];
      async function loadBrands() {
        const { data, error } = await supabase
          .from('brands')
          .select('id, name')
          .order('name');
        if (!error && data) {
          allBrands = data;
        }
      }
      
      const brandSearch = el('brand_search');
      const brandSuggestions = el('brand-suggestions');
      const brandNameInput = el('brand_name');
      const brandIdInput = el('brand_id');
      
      if (brandSearch) {
        brandSearch.addEventListener('input', function(e) {
          const query = e.target.value.toLowerCase().trim();
          if (query.length < 2) {
            brandSuggestions.classList.add('hidden');
            return;
          }
          
          const matches = allBrands.filter(brand => 
            brand.name.toLowerCase().includes(query)
          );
          
          if (matches.length > 0) {
            brandSuggestions.innerHTML = '';
            matches.forEach(brand => {
              const div = document.createElement('div');
              div.className = 'p-3 hover:bg-gray-50 cursor-pointer border-b border-gray-200 last:border-b-0';
              div.textContent = brand.name;
              div.addEventListener('mousedown', (e) => {
                e.preventDefault();
                brandIdInput.value = brand.id;
                brandNameInput.value = brand.name;
                brandSearch.value = brand.name;
                brandSuggestions.classList.add('hidden');
                
                // Load existing products and brand data (logo, website, address) for this brand
                loadBrandProducts(brand.id);
                loadBrandData(brand.id);
              });
              brandSuggestions.appendChild(div);
            });
            brandSuggestions.classList.remove('hidden');
          } else {
            brandSuggestions.classList.add('hidden');
          }
        });
        
        brandSearch.addEventListener('blur', function() {
          setTimeout(() => brandSuggestions.classList.add('hidden'), 200);
        });
      }
      
      // Load products for existing brand when selected
      async function loadBrandProducts(brandId) {
        console.log('üì¶ Loading products for brand ID:', brandId);
        
        if (!products) {
          console.error('‚ùå Products container element not found');
          return;
        }
        
        // Try the JOIN query first (more efficient)
        let { data: brandProducts, error } = await supabase
          .from('brand_products')
          .select('products(id, name, sku, upc), product_label')
          .eq('brand_id', brandId);
        
        // If JOIN fails, try fetching separately (fallback)
        if (error) {
          console.warn('‚ö†Ô∏è JOIN query failed, trying separate queries:', error.message);
          
          // Fetch brand_products without JOIN
          const { data: bpData, error: bpError } = await supabase
            .from('brand_products')
            .select('product_id, product_label')
            .eq('brand_id', brandId);
          
          if (bpError) {
            console.error('‚ùå Error loading brand products:', bpError);
            stat.textContent = `Error loading products: ${bpError.message}`;
            setTimeout(() => { stat.textContent = ''; }, 5000);
            return;
          }
          
          if (bpData && bpData.length > 0) {
            // Fetch products separately
            const productIds = bpData.map(bp => bp.product_id).filter(id => id);
            const { data: productsData, error: pError } = await supabase
              .from('products')
              .select('id, name, sku, upc')
              .in('id', productIds);
            
            if (pError) {
              console.error('‚ùå Error loading products:', pError);
              stat.textContent = `Error loading products: ${pError.message}`;
              setTimeout(() => { stat.textContent = ''; }, 5000);
              return;
            }
            
            // Combine the data
            brandProducts = bpData.map(bp => {
              const product = productsData?.find(p => p.id === bp.product_id);
              return {
                products: product,
                product_label: bp.product_label
              };
            }).filter(bp => bp.products); // Only include if product found
            
            error = null; // Clear error since we succeeded with fallback
          } else {
            brandProducts = [];
            error = null;
          }
        }
        
        if (error) {
          console.error('‚ùå Error loading brand products:', error);
          stat.textContent = `Error loading products: ${error.message}`;
          setTimeout(() => { stat.textContent = ''; }, 5000);
          return;
        }
        
        console.log('üìä Brand products query result:', { data: brandProducts, count: brandProducts?.length || 0 });
        
        if (brandProducts && brandProducts.length > 0) {
          // Clear existing product rows
          products.innerHTML = '';
          
          console.log(`‚úÖ Found ${brandProducts.length} products, adding to form...`);
          
          // Add existing products to form
          let addedCount = 0;
          brandProducts.forEach((bp, index) => {
            const product = bp.products;
            if (!product) {
              console.warn(`‚ö†Ô∏è Brand product ${index} has no associated product record`);
              return;
            }
            
            addProductRow();
            const lastRow = products.lastElementChild;
            if (lastRow) {
              const nameInput = lastRow.querySelector('[data-k="name"]');
              const barcodeInput = lastRow.querySelector('[data-k="barcode"]');
              
              if (nameInput) {
                nameInput.value = bp.product_label || product.name || '';
              }
              if (barcodeInput) {
                barcodeInput.value = product.sku || product.upc || '';
              }
              
              addedCount++;
              console.log(`  ‚úì Added product: ${bp.product_label || product.name || 'Unknown'}`);
            } else {
              console.error(`‚ùå Failed to add product row for product ${index}`);
            }
          });
          
          stat.textContent = `Loaded ${addedCount} product${addedCount !== 1 ? 's' : ''} for this brand`;
          setTimeout(() => { stat.textContent = ''; }, 3000);
        } else {
          console.log('‚ÑπÔ∏è No products found for this brand');
          stat.textContent = 'No products found for this brand';
          setTimeout(() => { stat.textContent = ''; }, 3000);
        }
      }
      
      // Load brand data (logo, website, address) when existing brand is selected
      async function loadBrandData(brandId) {
        const { data, error } = await supabase
          .from('brands')
          .select('logo_url, website, address')
          .eq('id', brandId)
          .single();
        
        if (!error && data) {
          // Load logo
          if (data.logo_url) {
            document.getElementById('brand_logo_url').value = data.logo_url;
            showLogoPreview(data.logo_url);
          }
          
          // Load website if not already filled
          const websiteInput = document.getElementById('brand_site');
          if (data.website && (!websiteInput.value || websiteInput.value === 'https://www.company.com')) {
            websiteInput.value = data.website;
          }
          
          // Load address if not already filled
          const addressInput = document.getElementById('brand_addr');
          if (data.address && (!addressInput.value || addressInput.value === 'Street, City, State, ZIP')) {
            addressInput.value = data.address;
          }
        }
      }
      
      // Show logo preview
      function showLogoPreview(url) {
        const preview = document.getElementById('brand_logo_preview');
        const previewImg = document.getElementById('brand_logo_preview_img');
        if (url && preview && previewImg) {
          previewImg.src = url;
          preview.classList.remove('hidden');
          previewImg.onerror = () => {
            preview.classList.add('hidden');
          };
        }
      }
      
      // Handle logo file selection
      document.addEventListener('DOMContentLoaded', () => {
        const logoFileInput = document.getElementById('brand_logo_file');
        const logoUrlInput = document.getElementById('brand_logo_url');
        
        if (logoFileInput) {
          logoFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = (event) => {
                showLogoPreview(event.target.result);
              };
              reader.readAsDataURL(file);
            }
          });
        }
        
        if (logoUrlInput) {
          logoUrlInput.addEventListener('blur', (e) => {
            const url = e.target.value.trim();
            if (url) {
              showLogoPreview(url);
            }
          });
        }
      });
      
      // Initialize: load brands for search
      loadBrands();

      document.getElementById('saveAll').onclick = async (e)=>{
        e.preventDefault();
        const btn = e.target; btn.disabled = true; btn.textContent = 'Saving‚Ä¶';
        try { await saveAll(); }
        finally { btn.disabled = false; btn.textContent = 'Deploy ShelfAssured'; }
      };
    })();
  </script>
</body>
</html>
